线程

一.线程的概念
	程序:一段代码,一组指令,它本身没有任何运行的含义 它只是一个实体 是应用软件执行的蓝本
	进程:是程序一次动态执行 它对应着从代码加载 执行 到执行完毕的一个完整的过程
	     它是动态的 它有自己的生命周期 
	     它因创建而产生 因调度而运行 因等待或事件而处于等待状态 因完成任务而结束
	线程: 线程就是进程里的一个控制单元 是线程在控制进程 
	      每一个进程里面都包含有若干个线程 一个进程至少要有一个线程
	      多线程并发执行可以提高程序的效率,可以同时完成多项工作

	进程和线程的区别:
		线程:进程的某个执行单元
		进程:一个进程可以包含多个线程,进程一般是由线程组成的 一个进程至少要有一个线程
	什么是多线程?
		多线程是实现了并发机制的一种有效手段一个进程包含多个线程共享内存
		同时运行 可以提高程序的执行效率
	多线程的并发和并行
		并行:就是两个任务同时运行 多核cpu (用两台电脑 分别和两个人聊天)
		并发:是指两个任务同时请求运行 而处理器一次只能接受一个任务 就会把两个任务安排轮流执行
			由cpu来决定 (用一台电脑 分别和两个聊天)
	java的程序运行原理
		java命令会启动jvm 等于启动了一个应用程序 
		也就是启动了一个进程 该进程为自动启动一个"主线程" 
		然后主线程去掉用某个类的main函数

	java的启动是多线程的吗?
		jvm启动至少启动了 主线程 和 垃圾回收线程 所以是多线程的
二.线程的创建方式

	线程运行状态
		虽然wait 但是 线程没结束 例如 程序死了 但进程还在
		任务管理器-->结束进程(强制干掉线程)

		线程被start()了之后却不一定运行 例如 开了四个线程 抢cpu但是 有一个一直没抢到

		冻结:放弃了执行资格 解冻之后 会回到 临时状态 

		NEW(出生)
			至今尚未启动的线程处于这种状态。 
		RUNNABLE(准备就绪和执行)
			正在 Java 虚拟机中执行的线程处于这种状态。 
		BLOCKED(睡眠)
			受阻塞并等待某个监视器锁的线程处于这种状态。 
		WAITING(等待)
			无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。 
		TIMED_WAITING(时间等待)
			等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。 
		TERMINATED(消亡)
			已退出的线程处于这种状态。

	1.继承Thread类
		java.lang 类 Thread
		线程 是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。 
		创建新执行线程有两种方法。一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。
		
		 * 创建线程的方式一
			 * 1.继承Thread类
			 * 2.重写run()方法
			 * 3.创建线程对象
			 * 4.启动线程 start()方法
		 * 多线程执行特性:
			 * 随机性 谁抢到cpu执行权 谁就执行 置于执行多长 cpu说的算
			 * 在某一个时刻 只能有一个程序在运行(多核除外)
		 * 为什么要重写run()方法?
			 * 因为想要执行自己特有的代码 run()方法 用于存储线程要运行的代码 
			   该存储功能是run()方法特有的
		Thread.currentThread().getName()

		// java.lang.IllegalThreadStateException
		// 指示线程没有处于请求操作所要求的适当状态时抛出的异常。
		// 因为 线程对象已经启动过了 然后 重复start 
		// 所以jvm告诉你 你已经启动过了 不要重复启动
	2.实现Runnable接口
		必须重写run()方法
		/*创建线程的第二种方式 实现 Runnable接口
		 * 步骤
		 * 	1.定义类 实现Runnable接口
		 *  2.重写run方法
		 *  3.通过Thread类建立线程对象
		 *  4.将Runnable接口的子类对象作为实际参数 传给 Thread类的构造方法
		 *  5.调用Thread类的start方法 开启线程 并调用 Runnable 接口子类的run方法
		 * */
	两个创建线程的方式区别
		使用Thread类 那么需要继承 并重写父类中的run方法
		实现Runnable接口 重写 接口中的run方法
		从扩展的角度来讲 最好使用 Runnable接口

		单继承 多实现 

		区别:
			实现方法 避免了单继承的局限性
			继承Thread: 线程的代码是存放在 Thread子类的run方法中
			实现Runnable: 线程的代码是存放在 Runnable 接口的子类run方法中 
				如果想要启动线程 必须创建线程 调用 Thread类中的start方法
				通过Thread类中start方法 来 启动 接口子类的run方法

	Thread 和 Runnable 的匿名实现方式

		匿名内部类 不用去创建子类 直接写成匿名的

三.线程安全 
	线程的安全隐患:
		在线程执行的时候 由于是多个线程在抢cpu的执行权 很有可能出现异常情况
		当多个线程操作一个共享数据时,一个线程语句只执行了一部分,还没执行完,
		另一个线程参与进来 抢走执行权 导致了共享数据的错误
	
	解决方法:
		对多条操作共享数据的语句,只能一个线程都执行完 在执行过程中,其他线程不能参与执行 等执行结束后
		再让另一个线程继续跑
	java对多线程的安全问题 提供了专业的解决方式 就是 同步
		synchronized

	1.同步代码块
		语法 synchronized(对象){
			包含的临界资源代码(要被同步处理的内容)
		}	
		锁:(对象) 里面传的是一个对象 这个对象可以是任意的 但是 对象必须唯一
	2.同步方法
		语法 访问权限修饰符 synchronized 返回值类型 方法名(参数列表){
			操作的代码(要被同步处理的内容)
		}
		同步方法 将同步定义在方法上 与对象无关 可以删掉Object对象

		思考:同步方法的锁是什么?
		锁:this	必须唯一 
	3.静态方法
		锁是: 类名.class 就是字节码文件 
			静态进入内存的时候 还没有对象 所以是类名点调用


同步的前提:
	1.必须要有两个或两个以上的线程 才需要锁
	2.必须是多个线程使用同一个锁 (3号车厢的卫生间 和 4号车厢的卫生间 锁没关系)

	注意:
		不要把run方法里的所有方法都放在同步代码块里,只需要同步那个共同操作的资源即可
	好处:
		解决多线程的安全问题
	弊端:
		多了一个锁的判断动作 所以消耗了资源 程序稍微变慢
	

死锁
	我不放我的锁 要进入到你那里去
	你不放你的锁 要进入到我这里来
	谁都不放
	僵持不下
	就死了

	死锁 不一定会发生 死锁 不等于 等待

	在同步代码块里 书写同步代码块 让多个线程等待对方释放锁标记 互相等待对方使用
	在使用锁对象标记的时候 程序出现暂停状态 称为 死锁

	尽量不要嵌套使用synchronized

以前线程安全的类回顾
	Vector,StringBuffer,HashTable
	Vector是线程安全 ArrayList 线程不安全
	StringBuffer是线程安全的 StringBuilder线程不安全
	HashTable是线程安全的	HashMap是线程不安全的