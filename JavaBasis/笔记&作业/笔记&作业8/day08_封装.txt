4.方法的参数传递 (值传递 引用传递)
	基本数据类型 值传递:当参数类型为基本数据类型的时候 传递的是值 出了方法 原有值不改变
	引用数据类型 引用传递:当参数类型为引用数据类型的时候 传的是堆内存中的地址 可以改变堆内存中地址对应的数据

5.static关键字 与类相关的 与对象无关 
	static 静态 

	static特点
		1.节省资源 可以把共性的东西抽取出来设置为静态 共有
		2.被静态修饰的成员 优先于对象加载入内存 随着类的加载 而加载
		3.当成员被静态修饰后,就多了一种调用方式 类名.静态成员
			可以用对象调用 但是不推荐
	注意:
		静态虽好 不可乱用
	
	与类相关的 与对象无关 

	修饰成员变量
		所属不同
			静态的成员变量
				属于类 所以也叫类变量
			非静态的成员变量
				属于对象 所以也称为 实例变量
		内存中位置不同
			静态的成员变量
				存储于方法区的静态区
			非静态的成员变量
				堆内存
		内存中出现的时间不同
			静态的成员变量 随着类的加载而加载 随着类的消失而消失 存活时间长
			非静态的成员变量 随着对象的存在而存在 随着对象的消失而消失
		调用不同
			静态 类名.调用 /对象.调用(不推荐)
			非静态 对象.调用
	修饰成员方法
		语法:
		访问权限修饰符 static 返回值类型 方法名(形参){
			//方法体
		}

		注意事项:
			1.静态方法 只能访问静态成员
			  非静态方法既可以访问静态,也可以访问非静态
			2.静态方法中 不可以定义 this / super关键字
			  因为静态优先于对象存在 所以静态方法中不可以出现非静态的this/super的成员
		静态只能访问静态
	总结:
		静态有利弊 使用需谨慎
		利: 将对象共享的数据进行单独存储 节省空间 可以直接用类名调用
		弊: 生命周期过长 访问出现局限性 静态虽好 只能访问静态

public static void main(String[] args) {

}
	1.public 访问权限修饰符 (访问权限最大控制符)
	2.static 静态的 随着类的加载 进入内存
	3.void 不确定的范围值 当前jvm 不需要这个方法带回返回值
	4.main 不是个关键字 jvm识别这个方法名 程序的入口
	5.String[]:存放String类型数据的数组 可以接收键盘录入
	6.args 数组名 不是关键字 arguments参数的意思

6.工具类
	什么叫工具 类:
		将某些共性的功能抽取出来 单独封装Java类 这样提高了复用性
	类 ArrayTool
		1.获取最大值
		2.数组的遍历
	
	工具类:
		私有化构造函数 因为不需要在其他类中创建对象
		将所有方法用static修饰 可以类名.调用
	好处:
		可以重复使用
	javadoc ArrayTool.java 可以生成java 文档API

静态代码块
	语法:
		static{
			//块体 静态代码块中的执行语句
		}
		随着类的加载而执行 只执行一次
			并优先于主函数 没名字比有名字的快
	作用:
		用于给类初始化的
		一般用于加载驱动
	构造代码块
		{
			用于给对象初始化的
		}
		没名字比有名字的快

7.Math类中的生成伪静态随机数方法
	Math类是在java.lang包中的 不用导包
	static double random() 
          返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。 
		// double d = Math.random();
		// 0.00000-9.99999
		// Math.random() ---> 0.00000 - 0.99999
		// (int)(Math.random()*10) --->  0 -9 
		// (int)(Math.random()*10)+1 ---> 1-10 
		
8.单例设计模式
	设计模式:解决一件事最快的方法 最行之有效的方法
	java中有23种设计模式 G.O.F
	设计模式 是纯理论 纯思想 不是代码层面的

单例:
	配置文件 只需要一个配置文件就可以了
	
	想要保证唯一性?
		1.为了避免其他程序过多建立该类对象,先禁止其他程序建立该类对象
		2.为了让其他程序可以访问到该类对象,只好在本类中,自定义一个对象
		3.为了方便其他程序对自定义对象的访问,可以对外提供一些访问方式

	这三步骤怎么用代码来实现?
		1.将构造函数私有化
		2.在本类中创建一个本类对象
		3.提供一个方法可以获取该类对象

	饿汉式 : 先初始化对象
		private Single(){}
		private static Single s = new Single();

		public static Single getSingle(){
			return s;
		}
	懒汉式 : 对象是方法被调用时 才初始化 也叫作延时加载
		private Single(){}
		private static Single s = null;

		public static Single getSingle(){
			if(s == null){
				s = new Single();
			}
			return s;
		}