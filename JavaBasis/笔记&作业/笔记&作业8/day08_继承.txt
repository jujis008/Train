面向对象特征二

继承
	父子继承
	父类: 超类 基类

	让类与类之间产生关系 子父类关系
	格式:
		class 子类名 extends 父类名{
		
		}
	继承好处:
		1.提高了代码的复用性 少写了代码
		2.让类与类之间产生关系,有了这个关系 才有了多态 是多态的前提

	is...a
		先有父 才有子

		类与类之间 有共性的关系 抽取出来的是父类
		子类继承父类 必须有关系 
	class A{
		void demo1(){}
		void demo2(){}
	}
	class B extends A{
		void demo1(){}
		void demo3(){}
	}
	继承弊端:
		1.类的耦合性增强了
		 开发的原则: 高内聚低耦合
		内聚: 就是自己完成某件事情的能力
		耦合: 类与类的关系
	java中继承的特点:
		1.只能单继承 不支持多继承
			一个儿子只能有一个爹 一个爹可以有多个儿子
	class A{
		void show(){
			System.out.println("a");
		}
	}
	class B{
		void show(){
			System.out.println("a");
		}
	}
	class C extends A,B{
	
	}

	C c = new C();
	c.show();
		2.java支持多层继承(继承体系)
查阅API文档

     如何使用一个继承体系中的功能呢?
	1.想要使用体系,先查阅父类的描述 因为父类中定义的是该体系中共性的功能
	  通过了解共性功能 你就能知道该体系的基本功能 那么这个体系基本已经可用了
	
	2.在具体调用时 要创建子类的对象 为什么?
		1.有可能父类不能创建对象
		2.创建子类对象 可以使用更多的功能 包括基本的功能和特有的(长江后浪推前浪)
	简单一句话:
		查阅父类功能 创建子类对象使用功能 (实际开发中)

继承中成员之间的关系

	继承中成员变量的关系
		/*
		成员变量
			同名
				就近原则 this.
				如果想要调用父类的 用 super.

				(开发中不会出现 同名现象 这只是教学)

			不同名
				直接用 或者 this./super. 都可以
		*/

		/*
		this:代表本类对象的引用
		super:代表父类对象的引用

		没有父 就没有子 在创建子类对象的时候 先加载父类的class 再加载子类
		*/

	继承中成员方法的关系
		同名:
			就近原则
		不同名:
			直接调用

		方法的重写:
			子父类出现了一模一样的方法
		重写有什么用?
			提高了代码的扩展性
			当子类需要父类的功能,而功能主体 子类特有的内容时,可以重写父类中的功能
			这样 即沿袭了父类的功能 又定义了子类的特有内容
		注意事项:
			1.父类私有方法 子类不能被重写
			2.子类重写父类方法时 访问权限不能更低(大于等于) 否则编译失败
			//private < 默认 < public 
			权限越来越小 那么继承体系 就崩溃了 
		重写:一模一样
	继承中构造方法的关系
	
