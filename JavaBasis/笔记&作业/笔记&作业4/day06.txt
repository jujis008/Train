一.方法的重载
	概念:在同一个类中,方法名相同,参数列表不同,与返回值无关

	参数列表不同: 顺序不同,类型不同
二.递归
	阶乘
		5! = 5*4*3*2*1
		5! = 5 *4! --->5*(5-1)!
		4! = 4 *3!
		3! = 3 *2!
		2! = 2 *1!
	递归:由此及彼,以此类推 自己调用自己的过程
		两个步骤:
			1.给程序一个出口 当满足这一条件的时候 循环结束
			2.在符合条件的情况下,简化同性质的问题,调用自己,得到问题的答案
三.数组
	什么是数组:
		就是用来存储同一种数据类型,定长的容器 
	类型:
		数组是引用数据类型
	数组的好处:
		1.可以存储多个同类型数据
		2.可以给这些数据从0开始编号,方便操作这些数据
	语法格式:
		1.动态初始化
			数据元素类型 [] 数组名 = new 数组元素类型 [数组中的元素个数];
				int [] x = new int[3];
		2.静态初始化
			数组元素类型 [] 数组名 = new 数组元素类型[]{元素1,元素2....};
				int [] x = new int[]{20,30,40};
				//注意:静态初始化[] 不写长度 会根据你元素的多少 给数组长度
			数组元素类型 [] 数组名 = {元素1,元素2.....};

	什么时候用静态初始化 什么时候用动态初始化

		当确定了元素内容,就用静态初始化.(静态初始化 格式 new 数组元素类型[])
		当确定了数组长度,不确定元素内容,用动态初始化
内存分析:
	java程序在运行时,需要在内存中分配空间,为了提高运算效率,又对空间进行了不同区域的划分,
	因为每一篇区域都有特定的处理数据方式和内存管理方式

	栈内存
		用于存储局部变量 (方法里的,形式参数列表,定义在for循环) 当数据使用完 自动释放
	堆内存
		用于存储数组和对象 通过new建立的实例都放在堆内存中
		每一个实体都有一个内存地址值
		实体中的变量都有默认初始化值
			byte,short,int --->0
			long---> 0L
			float ---> 0.0F
			double --->0.00
			boolean --->false
			char ---> \u0000 --->表示空
			引用数据类型 --->null
		垃圾回收机制 当实体不在被使用,会在不确定的时间呗垃圾回收器回收
			小知识: c++ 需要手动回收 java是自动回收
	方法区 本地方法区 寄存器

遍历数组的两种方式
	1.普通for循环
		for(int i=0;i<x.length;i++){ //i不只是循环条件 还是数组的角标 从0开始

				System.out.print(x[i]+" ");

			}
	2.增强for循环[ForEach循环]
		语法: 
		for(数组中元素的类型 变量 : 数组名){
			数组中的元素类型 临时变量 = 变量;
		}
	区别:
		普通for 循环变量 代表角标 在循环体中 可以 获取角标 /元素 可以进行复杂的操作
		增强for 变量 代表的是 数组中的元素 不存在角标的意思 
数组的排序:
	排序也是比较 但是和求最值有些不同 从小到大排序 或者从大到小
	1.选择排序
		选择一个位置 拿这个位置的值不断和其他位置的值进行比较
	2.冒泡排序
		相邻两个元素 进行比较
	3.快速排序
		1.设置起始点 /结束点 和一个基准值
		2.将 比 基准值 小的移动到左边 大的移动到右边
			起始点 循环 右移 
			结束点 循环 左移
		3.让比 基准值 小的范围扩大 让比 基准值 大的范围扩大
		当 起始点 和 结束点 错开后 证明第一轮循环结束

		递归去反复做 2,3步
数组角标的查找:
	1.顺序查找 
	2.二分查找/折半查找
		前提:必须是有序数列 升序/降序都可以
		通过将待查找的元素与中间索引值对应的元素进行比较,
		若小于中间元素,去左边 end = middle-1
		若大于中间元素,去右边 start = middle+1
		继续折半 直到当arr[middle] == 元素 就找到了  否则返回一个负数
	
